<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini Geometry Dash</title>
  <style>
    body,html{margin:0;padding:0;height:100%;background:#111;color:#fff;font-family:sans-serif;display:flex;align-items:center;justify-content:center}
    #game{background:#222;display:block;width:100%;max-width:900px;height:70vh;border:2px solid #444;border-radius:8px;touch-action:none}
    .hud{position:absolute;top:10px;left:10px;font-weight:bold}
  </style>
</head>
<body>
  <div style="position:relative;width:100%;max-width:900px;">
    <canvas id="game"></canvas>
    <div class="hud">Score: <span id="score">0</span></div>
  </div>

  <script>
    (function(){
      const canvas=document.getElementById('game');
      const ctx=canvas.getContext('2d');
      let W,H;
      function resize(){
        W=canvas.offsetWidth;H=canvas.offsetHeight;
        canvas.width=W;canvas.height=H;
      }
      window.addEventListener('resize',resize);resize();

      let running=false,lastTime=0,score=0;
      const scoreEl=document.getElementById('score');

      // load player texture
      const playerImg=new Image();
      playerImg.src="/mnt/data/cube_60.png"; // uploaded texture

      // player (cube)
      const player={x:80,y:0,w:40,h:40,vy:0,gravity:1500,jump:-600,onGround:false,angle:0};

      // ground and obstacles
      const ground=H-60;
      const obstacles=[];
      let spawnTimer=0;

      function start(){
        running=true;score=0;obstacles.length=0;
        player.x=80;player.y=ground-player.h;player.vy=0;player.onGround=true;player.angle=0;
        lastTime=performance.now();
        requestAnimationFrame(loop);
      }

      function spawn(){
        const size=40+Math.random()*20;
        obstacles.push({x:W,y:ground-size,w:size,h:size});
      }

      function update(dt){
        // gravity
        player.vy+=player.gravity*dt;
        player.y+=player.vy*dt;
        if(player.y+player.h>=ground){
          player.y=ground-player.h;player.vy=0;player.onGround=true;
        } else player.onGround=false;

        // rotate while in air
        if(!player.onGround){
          player.angle += 8*dt; // radians per second
        } else {
          player.angle=0;
        }

        // obstacles
        spawnTimer-=dt;
        if(spawnTimer<=0){spawn();spawnTimer=1.5+Math.random()*1.2;}
        for(let i=obstacles.length-1;i>=0;i--){
          const o=obstacles[i];
          o.x-=400*dt;
          if(o.x+o.w<0){obstacles.splice(i,1);score++;scoreEl.textContent=score;}
          if(!(player.x+player.w<o.x||player.x>o.x+o.w||player.y+player.h<o.y||player.y>o.y+o.h)){
            running=false;alert("Game Over! Score: "+score);return;
          }
        }
      }

      function render(){
        ctx.clearRect(0,0,W,H);
        // ground
        ctx.fillStyle="#333";ctx.fillRect(0,ground,W,H-ground
